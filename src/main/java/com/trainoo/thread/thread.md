```
monitor  显示屏，监督，监视

新建new 就绪runnable 运行running 阻塞blocked 死亡dead

前台线程创建的子线程默认是前台线程，后台线程创建的子线程默认是后台线程。

前台线程跟后台线程的区别是：
应用程序必须运行完所有的前台线程才可以退出；而对于后台线程，应用程序可以不考虑其是否已经运行完毕而直接退出，所有的后台线程在应用程序退出时都会自动结束，JVM通知后台线程死亡，但从接受指令到做出响应，需要一定的时间。

每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。

具有较好优先级的线程具有较多的执行机会，而非优先执行。

wait:导致当前线程等待并使其进入到等待阻塞状态，直到其他线程调用该同步锁对象的notify()或者notifyAll()方法来唤醒此线程

notify:唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁的锁定，才可能执行被唤醒的线程。

notifyAll:唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。

yield()是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield的目的是让相同优先级的线程之间能够适当的轮转执行，但是，实际中无法保证达到让步目的，因为让步的线程还是有可能被线程调度程序在次选中。

start()方法的调用并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是操作系统决定的。

join()的作用是：“等待该线程终止”，如在main中执行t1.join，那么main线程会等待t1线程终止之后再结束。

Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU的同时，释放了对象锁的控制。

多线程程序是乱序执行的，因此，只有乱序执行的代码才有必要设计为多线程。

Thread类实际上也是实现了Runnable接口的类。

实现Runnable接口比继承Thread类所具有的优势：
1.适合多个相同的程序代码的线程去处理同一个资源；
2.可以避免Java的单继承的限制；
3.增加程序的健壮性，代码可以被多个线程共享，代码和数据独立；
4.线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类。

在Java中，每次程序运行至少启动2个线程，一个是main线程，一个是垃圾收集线程。

# 自旋锁的概念：
首先是一种锁，与互斥锁相似，基本作用是用于线程（进程）之间的同步。与普通锁不同的是，一个线程A在获得普通锁后，如果再有线程B试图获取锁，那么这个线程B将会挂起（阻塞）；试想下，如果两个线程资源竞争不是特别激烈，而处理器阻塞一个线程引起的线程上下文的切换的代价高于等待资源的代价的时候（锁的已保持者保持锁时间比较短），那么线程B可以不放弃CPU时间片，而是在“原地”忙等，直到锁的持有者释放了该锁，这就是自旋锁的原理，可见自旋锁是一种非阻塞锁。

# 自旋锁可能引起的问题：
1.过多占据CPU时间：如果锁的当前持有者长时间不释放该锁，那么等待者将长时间的占据cpu时间片，导致CPU资源的浪费，因此可以设定一个时间，当锁持有者超过这个时间不释放锁时，等待者会放弃CPU时间片阻塞；
2.死锁问题：试想一下，有一个线程连续两次试图获得自旋锁（比如在递归程序中），第一次这个线程获得了该锁，当第二次试图加锁的时候，检测到锁已被占用（其实是被自己占用），那么这时，线程会一直等待自己释放该锁，而不能继续执行，这样就引起了死锁。因此递归程序使用自旋锁应该遵循以下原则：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。

# 可重入锁：
就是一个线程A在获取了锁之后，再次去获取同一个锁，此时仅仅是吧状态值进行累加，如果A释放了一次锁，则状态值减1，直到状态值减到0了，其他线程才有机会获取锁。
ReentrantLock支持两种获取锁的方式，一种是公平模型，一种是非公平模型。

# 悲观锁：
指的是对数据被外界修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。
悲观锁的实现，往往依靠数据库提供的锁机制。

# 乐观锁：
相对悲观锁而的言，乐观锁机制采取了更加宽松的加锁机制，悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。
乐观锁机制在一定的程度上解决了这个问题，乐观锁，大多是基于数据版本记录机制实现，何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个version字段来实现。

```